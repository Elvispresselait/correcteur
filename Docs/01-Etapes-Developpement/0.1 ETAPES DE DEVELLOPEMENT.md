# Guide de d√©veloppement : ChatBot correcteur macOS (SwiftUI)

## Vue d'ensemble
Application macOS native en Swift/SwiftUI avec interface similaire √† ChatGPT, optimis√©e pour mode portrait, permettant de corriger du texte avec surlignement des corrections.

---

## üìã √âTAPE 1 : Structure de base et layout portrait

### Prompt pour Cursor :

```
Cr√©e une application macOS en SwiftUI avec la structure suivante :

1. Fen√™tre principale en mode portrait (largeur : 400pt, hauteur : 700pt minimum)
2. Layout horizontal avec :
   - Sidebar gauche (largeur fixe 200pt) avec :
     * Bouton "+ Nouveau chat" en haut
     * Liste scrollable des conversations pr√©c√©dentes
     * Chaque √©l√©ment de conversation affiche le titre tronqu√©
   - Zone principale droite avec :
     * Header fixe en haut (50pt de hauteur, fond gris clair)
     * Zone de messages scrollable au centre
     * Barre de saisie en bas (100pt de hauteur) avec TextField multiligne et bouton Envoyer

3. Style :
   - Couleurs : fond blanc, sidebar gris #F7F7F8, accents bleu #0066CC
   - Polices : SF Pro syst√®me
   - Coins arrondis pour les bulles de messages
   - Ombres l√©g√®res pour la profondeur

4. Structure de donn√©es minimale :
   - struct Conversation: Identifiable (id, titre, messages)
   - struct Message: Identifiable (id, contenu, isUser)

G√©n√®re uniquement le code SwiftUI pour cette structure visuelle sans logique backend.
Assure-toi que la sidebar soit collapsible avec un bouton toggle.
```

**Validation** : L'interface doit ressembler visuellement √† ChatGPT avec sidebar, zone de chat et input en bas.

---

## üìã √âTAPE 2 : Am√©lioration UI et gestion d'√©tat local

### Prompt pour Cursor :

```
Am√©liore l'application pr√©c√©dente avec :

1. Gestion d'√©tat avec @StateObject et ObservableObject :
   - Classe ChatViewModel qui g√®re :
     * Liste des conversations
     * Conversation active
     * Ajout/suppression de conversations
     * Ajout de messages √† la conversation active

2. Interactions fonctionnelles :
   - Le bouton "+ Nouveau chat" cr√©e une nouvelle conversation vide
   - Cliquer sur une conversation dans la sidebar la charge
   - Le TextField multiligne permet d'√©crire plusieurs lignes
   - Le bouton Envoyer ajoute le message √† la conversation (alternance user/assistant)
   - Pour l'instant, la "r√©ponse" de l'assistant est juste un echo : "Vous avez dit : [message]"

3. Bulles de messages stylis√©es :
   - Messages utilisateur : align√©s √† droite, fond bleu clair, texte noir
   - Messages assistant : align√©s √† gauche, fond gris clair, texte noir
   - Markdown basique : texte **gras**, ~~barr√©~~, texte soulign√© (AttributedString)
   - Auto-scroll vers le bas quand un nouveau message arrive

4. Header dynamique :
   - Affiche le titre de la conversation active
   - Bouton pour renommer la conversation (simple alert avec TextField)

Utilise SwiftUI natif uniquement, pas de d√©pendances externes.
```

**Validation** : On peut cr√©er des conversations, envoyer des messages, voir l'historique, et le texte stylis√© (gras, barr√©, soulign√©) s'affiche correctement.

---

## üìã √âTAPE 3 : S√©lection de prompt syst√®me dans le header

### Prompt pour Cursor :

```
Ajoute dans le header de l'application :

1. Menu d√©roulant (Picker) pour s√©lectionner le prompt syst√®me :
   - Position : √† droite du titre de la conversation dans le header
   - Options :
     * "Correcteur orthographique" (par d√©faut)
     * "Assistant g√©n√©ral"
     * "Traducteur"
     * "Personnalis√©"
   
2. Si "Personnalis√©" est s√©lectionn√© :
   - Afficher un Sheet modal avec TextEditor multiligne
   - Permettre de saisir/modifier le prompt syst√®me personnalis√©
   - Bouton "Enregistrer" pour valider
   
3. Stocker le prompt syst√®me s√©lectionn√© dans ChatViewModel :
   - Propri√©t√© currentSystemPrompt: String
   - Charger le prompt appropri√© selon la s√©lection
   - Le prompt "Correcteur orthographique" doit √™tre :

"""
Je veux que tu ne regardes que la partie surlign√©e.
Tu me la re-rediges compl√®tement en respectant les retours √† la ligne.

Ensuite pour chaque faute, tu me rayes le mot entier o√π il y a la faute, ou les mots entiers o√π il y a les fautes.
Tu rajoutes un espace devant avec et tu mets en gras et soulign√©s les mots que tu rajoutes pour corriger.

Ensuite, devant chaque paragraphe que tu as modifi√©, je veux que tu rajoutes une croix rouge (‚ùå).
Et pour les autres paragraphes qui restent, je veux que tu rajoutes une croix verte (‚úÖ) devant chaque paragraphe.
"""

4. Design :
   - Picker compact avec ic√¥ne d'engrenage
   - Style coh√©rent avec le reste de l'interface

Ne connecte pas encore √† l'API OpenAI, utilise toujours l'echo pour les r√©ponses.
```

**Validation** : On peut s√©lectionner diff√©rents prompts syst√®me, voir/modifier le prompt personnalis√©, l'interface reste propre et utilisable.

---

## üìã √âTAPE 4 : Support du copier-coller d'images

### Prompt pour Cursor :

```
Ajoute le support des images dans l'application :

1. D√©tection du copier-coller :
   - Sur le TextField de saisie, d√©tecter quand l'utilisateur colle (Cmd+V)
   - V√©rifier si le clipboard contient une image (NSPasteboard)
   - Si oui, extraire l'image et l'ajouter au message

2. Structure de donn√©es √©tendue :
   - Modifier struct Message pour supporter :
     * contenu texte (String)
     * images optionnelles ([NSImage]?)
   - Permettre plusieurs images par message

3. Affichage des images :
   - Dans les bulles de messages, afficher les images avant le texte
   - Images redimensionn√©es (largeur max 300pt, ratio pr√©serv√©)
   - Si plusieurs images, affichage en grille 2 colonnes
   - Thumbnail cliquable pour voir en taille r√©elle (Sheet modal)

4. Zone de preview avant envoi :
   - Quand une image est coll√©e, afficher un preview au-dessus du TextField
   - Bouton "X" pour retirer l'image avant envoi
   - Afficher le nombre d'images attach√©es

Utilise NSImage et les APIs natives macOS pour la gestion du clipboard.
Ne connecte pas encore √† l'API, les images sont juste affich√©es dans l'UI.
```

**Validation** : On peut coller des images (Cmd+V), les voir en preview, les envoyer avec le message, et les visualiser dans l'historique.

---

## üìã √âTAPE 5 : Configuration de la cl√© API OpenAI

### Prompt pour Cursor :

```
Ajoute la gestion de la cl√© API OpenAI :

1. Fen√™tre de Settings (Pr√©f√©rences) :
   - Accessible via menu "Pr√©f√©rences" ou raccourci Cmd+,
   - Section "API Configuration" avec :
     * TextField s√©curis√© (SecureField) pour la cl√© API
     * Bouton "Tester la connexion"
     * Label de statut (‚úÖ Connect√© / ‚ùå Non connect√© / ‚è≥ Test en cours)
     * Lien vers la page OpenAI pour obtenir une cl√© API

2. Stockage s√©curis√© :
   - Utiliser Keychain (Security framework) pour stocker la cl√© API
   - Classe APIKeyManager avec m√©thodes :
     * saveAPIKey(_ key: String)
     * loadAPIKey() -> String?
     * deleteAPIKey()

3. Gestion de l'√©tat :
   - Variable @AppStorage ou @State pour tracking si la cl√© est configur√©e
   - Si pas de cl√© au lancement, afficher un banner en haut de l'app :
     "‚ö†Ô∏è Cl√© API non configur√©e. Ouvrez les Pr√©f√©rences pour configurer."

4. Test de connexion simple :
   - Appel basique √† l'API OpenAI (endpoint models list)
   - URLSession natif pour la requ√™te HTTP
   - Afficher le r√©sultat (succ√®s/√©chec) dans le label de statut
   - G√©rer les erreurs courantes (cl√© invalide, pas de connexion internet)

Ne connecte pas encore le chat √† l'API, c'est juste la configuration.
Ajoute des instructions claires dans un .md p√©dagogique sur o√π obtenir la cl√© API OpenAI et comment la configuer avec un exemple concret
```

**Validation** : On peut sauvegarder une cl√© API, elle est stock√©e en s√©curit√© dans Keychain, et le test de connexion fonctionne.

---

## üìã √âTAPE 6 : Int√©gration API OpenAI - Test basique

### Prompt pour Cursor :

```
Cr√©e le service API OpenAI basique :

1. Classe OpenAIService avec :
   - M√©thode sendMessage(message: String, systemPrompt: String) async throws -> String
   - Utilise l'endpoint chat/completions d'OpenAI
   - Mod√®le : gpt-4o-mini (√©conomique pour les tests)
   - Headers : Authorization avec Bearer token, Content-Type: application/json
   - Body JSON :
     {
       "model": "gpt-4o-mini",
       "messages": [
         {"role": "system", "content": "[systemPrompt]"},
         {"role": "user", "content": "[message]"}
       ]
     }

2. Gestion d'erreurs :
   - Enum custom pour les erreurs API (noAPIKey, invalidResponse, networkError, etc.)
   - Try/catch avec messages d'erreur explicites
   - Logging basique dans la console pour debug

3. Test simple dans l'UI :
   - Dans ChatViewModel, remplace l'echo par un appel √† OpenAIService
   - Quand l'utilisateur envoie un message :
     * Afficher imm√©diatement le message user
     * Afficher un message temporaire "assistant" avec "..." (typing indicator)
     * Faire l'appel API en async
     * Remplacer le "..." par la vraie r√©ponse
   - G√©rer les erreurs avec une alerte utilisateur

4. PAS de support d'images pour l'instant, uniquement texte.

Utilise async/await et @MainActor pour les mises √† jour UI.
Teste avec un message simple comme "Dis bonjour" pour v√©rifier que √ßa marche.
```

**Validation** : On peut envoyer un message texte simple et recevoir une vraie r√©ponse de ChatGPT. Les erreurs sont g√©r√©es proprement.

---

## üìã √âTAPE 7 : Mode conversation avec historique

### Prompt pour Cursor :

```
Am√©liore OpenAIService pour supporter l'historique conversationnel :

1. Modifier sendMessage pour accepter un historique :
   - Nouvelle signature : sendMessage(messages: [Message], systemPrompt: String) async throws -> String
   - Convertir [Message] en format API OpenAI :
     * Messages user ‚Üí {"role": "user", "content": "..."}
     * Messages assistant ‚Üí {"role": "assistant", "content": "..."}
   - Envoyer tout l'historique dans le body JSON (array messages)

2. Dans ChatViewModel :
   - Passer toute la conversation active √† l'API (pas juste le dernier message)
   - Limiter l'historique envoy√© aux 20 derniers messages pour √©conomiser tokens
   - Toujours inclure le systemPrompt en premier message
   - Filtrer les messages temporaires (indicateur de chargement)

Teste que l'assistant se souvient du contexte pr√©c√©dent dans la conversation.
```

**Validation** : ‚úÖ **TERMIN√â** - Le chatbot maintient le contexte conversationnel, se souvient des messages pr√©c√©dents, et les nouvelles conversations repartent de z√©ro.

---

## üìã √âTAPE 7.5 : Am√©liorations UI/UX et design √©pur√©

### Objectif :
Nettoyer l'interface, am√©liorer l'ergonomie et cr√©er une exp√©rience utilisateur fluide.

### Modifications apport√©es :

**1. Nettoyage de l'interface :**
- ‚úÖ Suppression des 3 conversations de d√©monstration (mock data)
- ‚úÖ L'application d√©marre avec 0 conversation (interface propre)
- ‚úÖ Suppression du bouton de test (fiole) inutilis√© dans le header

**2. Design √©pur√© - Suppression des coins arrondis :**
- ‚úÖ Sidebar : Coins nets √† 90¬∞ au lieu de `cornerRadius: 28`
- ‚úÖ Header du chat : Plus de `UnevenRoundedRectangle` arrondi
- ‚úÖ Zone de saisie (InputBar) : Rectangle net
- ‚úÖ Conteneur principal (ContentView) : Plus de `cornerRadius: 34`

**3. Repositionnement des √©l√©ments :**
- ‚úÖ Bouton de renommage (crayon ‚úèÔ∏è) : D√©plac√© juste √† c√¥t√© du titre de conversation
- ‚úÖ Suppression de l'ic√¥ne "doc.text" inutile √† c√¥t√© du titre
- ‚úÖ Bouton image : Repositionn√© **au-dessus** du bouton d'envoi avec style rond identique

**4. Optimisation des espacements :**
- ‚úÖ ContentView : `padding(24)` ‚Üí `padding(0)`
- ‚úÖ Header : Padding r√©duit de 24/24/14 ‚Üí 16/12/8, hauteur 56 ‚Üí 48
- ‚úÖ InputBar : Padding r√©duit de 24 ‚Üí 16 et vertical de 24/12 ‚Üí 12/8
- ‚úÖ Sidebar : Padding r√©duit de 14/18 ‚Üí 12/12
- ‚úÖ ImagePreview : Padding r√©duit de 24/12/8 ‚Üí 16/8/4
- ‚úÖ Interface plus compacte avec moins d'espaces inutiles

**5. Am√©lioration du bouton image :**
- ‚úÖ Ic√¥ne agrandie : 14pt ‚Üí 16pt
- ‚úÖ Bulle plus grosse : padding 14 (identique au bouton d'envoi)
- ‚úÖ Couleur unifi√©e : `#4F8CFF` (m√™me couleur que le bouton d'envoi)
- ‚úÖ Style rond 100% (Circle) avec ic√¥ne centr√©e

**6. Raccourcis clavier intelligents :**
- ‚úÖ **Entr√©e** : Envoie le message automatiquement
- ‚úÖ **Shift+Entr√©e** : Cr√©e une nouvelle ligne (retour √† la ligne)
- ‚úÖ Impl√©mentation dans `TextEditorWithImagePaste.swift` via event monitoring

**Validation** : ‚úÖ **TERMIN√â** - Interface √©pur√©e avec coins nets, espacements optimis√©s, boutons harmonis√©s, et raccourcis clavier fonctionnels.

### üìù √âTAPE 7.1 (Optionnel) : Affichage des tokens

```
3. Gestion du contexte :
   - Afficher le nombre de tokens estim√©s dans le header (approximation : 4 chars = 1 token)
   - Warning visuel si la conversation d√©passe 3000 tokens
   - Option "Nouvelle conversation" pour reset le contexte
```

### üìù √âTAPE 7.2 (Optionnel) : Optimisations avanc√©es

```
4. Optimisations :
   - Debounce : emp√™cher l'envoi de multiples messages simultan√©s
   - Annulation : bouton "Stop" pour annuler une g√©n√©ration en cours
   - Retry : bouton pour reg√©n√©rer la derni√®re r√©ponse en cas d'erreur
```

---

## üìã √âTAPE 8 : Support des images dans l'API (Vision)

### Prompt pour Cursor :

```
Ajoute le support des images dans les appels API :

1. Modifier OpenAIService pour GPT-4 Vision :
   - Utiliser le mod√®le "gpt-4o" au lieu de "gpt-4o-mini"
   - Format de message avec image :
     {
       "role": "user",
       "content": [
         {"type": "text", "text": "..."},
         {"type": "image_url", "image_url": {"url": "data:image/jpeg;base64,..."}}
       ]
     }

2. Conversion d'images :
   - M√©thode pour convertir NSImage en base64 Data URL
   - Compression JPEG (qualit√© 80%) pour limiter la taille
   - Limite de taille : 4MB par image (afficher erreur si d√©pass√©)
   - Support formats : JPEG, PNG, GIF, WebP

3. Dans ChatViewModel :
   - D√©tecter si un message contient des images
   - Si oui, utiliser gpt-4o, sinon utiliser gpt-4o-mini (√©conomie)
   - Convertir les images en base64 avant l'envoi API

4. UI feedback :
   - Afficher dans le message assistant si une image a √©t√© analys√©e
   - Indicateur de chargement diff√©rent pour les requ√™tes avec images (plus lent)
   - Gestion d'erreur sp√©cifique si l'image est trop grande ou format non support√©

Teste en collant une image et en demandant "D√©cris cette image".
```

**Validation** : On peut envoyer des messages avec images, et GPT-4o Vision analyse correctement les images et r√©pond en cons√©quence.

---

## üìã √âTAPE 9 : Persistance et sauvegarde des conversations

### Prompt pour Cursor :

```
Ajoute la persistance locale des conversations :

1. Stockage avec Core Data ou FileManager :
   - Option recommand√©e : JSON avec FileManager (plus simple)
   - Structure de fichiers :
     ~/Library/Application Support/[AppName]/conversations/
     - conversation_[uuid].json pour chaque conversation
     - index.json pour la liste des conversations
   
2. Mod√®les Codable :
   - Rendre Conversation et Message conformes √† Codable
   - Encoder/d√©coder automatiquement en JSON
   - Stocker aussi le systemPrompt utilis√© par conversation

3. Fonctionnalit√©s :
   - Auto-save apr√®s chaque message envoy√©/re√ßu
   - Load au d√©marrage de l'app (charger les 50 derni√®res conversations)
   - Bouton "Supprimer" sur chaque conversation (swipe to delete)
   - Bouton "Tout effacer" dans les pr√©f√©rences
   - Export d'une conversation en Markdown (share button)

4. Performance :
   - Lazy loading : ne charger que les conversations visibles dans la sidebar
   - Charger les messages d'une conversation uniquement quand elle est ouverte
   - Background queue pour les op√©rations de lecture/√©criture

Assure-toi que les donn√©es survivent √† un red√©marrage de l'app.
```

**Validation** : Les conversations sont sauvegard√©es automatiquement, persistent apr√®s fermeture/r√©ouverture de l'app, et peuvent √™tre supprim√©es.

---

## üìã √âTAPE 10 : Polish final et UX

### Prompt pour Cursor :

```
Finalise l'application avec les touches finales :

1. Animations et transitions :
   - Transition douce lors du changement de conversation
   - Animation de typing indicator (trois points anim√©s)
   - Fade in des nouveaux messages
   - Smooth scroll automatique vers le bas

2. Raccourcis clavier :
   - Cmd+N : Nouvelle conversation
   - Cmd+Return : Envoyer le message
   - Cmd+, : Pr√©f√©rences
   - Cmd+K : Focus sur la barre de recherche (ajoute une recherche dans les conversations)
   - Escape : Annuler la g√©n√©ration en cours

3. Recherche dans les conversations :
   - Barre de recherche en haut de la sidebar
   - Filtrage en temps r√©el des conversations par titre ou contenu
   - Highlight des r√©sultats

4. Am√©lioration du rendu Markdown :
   - Support complet du Markdown dans les r√©ponses :
     * Gras : **texte**
     * Italique : *texte*
     * Barr√© : ~~texte~~
     * Soulign√© : <u>texte</u> (HTML)
     * Code inline : `code`
     * Blocs de code avec coloration syntaxique
     * Listes √† puces et num√©rot√©es
     * Emojis (‚ùå, ‚úÖ, etc.)

5. Dark mode :
   - Support automatique du dark mode macOS
   - Adaptation des couleurs pour une bonne lisibilit√©

6. Ic√¥ne et branding :
   - Ajouter une ic√¥ne d'app professionnelle
   - Nom de l'app : "Correcteur Pro" ou similaire
   - About window avec version et cr√©dits

Teste l'app de bout en bout en simulant un usage r√©el.
```

**Validation** : L'application est fluide, intuitive, supporte le Markdown complet avec soulignement visible, et tous les raccourcis fonctionnent.

---

## üìã README : Instructions pour l'utilisateur final

### Contenu du README.md :

```markdown
# Correcteur Pro - Assistant de correction orthographique

Application macOS native pour corriger vos textes avec l'aide de ChatGPT.

## Installation

1. T√©l√©chargez l'application
2. Glissez-la dans votre dossier Applications
3. Lancez l'application

## Configuration de la cl√© API OpenAI

‚ö†Ô∏è **Cette application n√©cessite une cl√© API OpenAI pour fonctionner.**

### Obtenir votre cl√© API :

1. Allez sur [platform.openai.com](https://platform.openai.com)
2. Cr√©ez un compte ou connectez-vous
3. Allez dans "API Keys" dans votre dashboard
4. Cliquez sur "Create new secret key"
5. Copiez la cl√© (elle commence par `sk-...`)

### Configurer dans l'application :

1. Ouvrez les Pr√©f√©rences (Cmd+,)
2. Collez votre cl√© API dans le champ pr√©vu
3. Cliquez sur "Tester la connexion"
4. Si ‚úÖ appara√Æt, vous √™tes pr√™t !

## Utilisation

1. Copiez le texte √† corriger (avec surlignage si besoin)
2. Collez-le dans l'application (Cmd+V)
3. Appuyez sur Envoyer (Cmd+Return)
4. Les corrections apparaissent avec :
   - ‚ùå pour les paragraphes modifi√©s
   - ‚úÖ pour les paragraphes non modifi√©s
   - Mots barr√©s pour les erreurs
   - **Mots en gras soulign√©s** pour les corrections

## Raccourcis clavier

- `Cmd+N` : Nouvelle conversation
- `Cmd+Return` : Envoyer
- `Cmd+,` : Pr√©f√©rences
- `Escape` : Annuler la g√©n√©ration

## Tarification

L'application est gratuite, mais utilise votre cr√©dit API OpenAI :
- GPT-4o-mini : ~0.15$ / million de tokens (texte seul)
- GPT-4o : ~5$ / million de tokens (avec images)

Un usage normal co√ªte environ 0.01-0.10$ par correction.
```

---

## üéØ R√©sum√© de la progression

| √âtape | Objectif | Validation |
|-------|----------|------------|
| 1 | Structure UI de base | Layout visible et fonctionnel |
| 2 | Gestion d'√©tat locale | Conversations et messages affich√©s |
| 3 | S√©lection prompt syst√®me | Menu fonctionnel avec prompts |
| 4 | Support images (UI) | Copier-coller d'images op√©rationnel |
| 5 | Configuration API | Cl√© API sauvegard√©e et test√©e |
| 6 | API basique texte | Premi√®re r√©ponse de ChatGPT |
| 7 | Mode conversation | ‚úÖ Contexte maintenu entre messages |
| 8 | API avec images | Vision GPT-4o analyse les images |
| 9 | Persistance | Donn√©es sauvegard√©es et restaur√©es |
| 10 | Polish final | App compl√®te et utilisable |

## ‚öôÔ∏è Stack technique

- **Frontend** : SwiftUI (natif macOS)
- **Backend** : URLSession (HTTP natif)
- **Stockage** : FileManager + JSON
- **S√©curit√©** : Keychain (cl√© API)
- **API** : OpenAI GPT-4o et GPT-4o-mini

**Aucune d√©pendance externe requise** - tout est natif macOS/Swift.